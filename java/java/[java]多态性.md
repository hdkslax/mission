# [java]多态性Polymorphism

### 多态性在Java中的体现

- 对象的多态性：父类的引用指向子类的对象
- 可以直接应用在抽象类的接口上



### 引用变量的2个类型：编译时类型 & 运行时类型

- 编译时类型：由声明该变量时使用的类型决定
- 运行时类型：由实际赋给该变量的对象决定
- 编译时看左边，运行时看右边
- 若编译时类型和运行时类型不一致， 就出现了对象的多态性(Polymorphism)  
- 多态情况下：
  -  “看左边” ： 看的是父类的引用（父类中不具备子类特有的方法）
  - 看右边” ： 看的是子类的对象（实际运行的是子类重写父类的方法）  



### 对象的多态

- 在Java中，子类的对象可以替代父类的对象使用

  - 一个变量只能有一种确定的数据类型
  - 一个引用类型变量可能指向（引用）多种不同类型的对象

  ```java
  Person p = new Student();
  Object o = new Person(); // Object类型的变量o，指向Person类型的对象
  o = new Student(); // Object类型的变量o，指向Student类型的对象
  ```

- 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。

- 一个引用类型的变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就**不能**再访问子类中添加的属性和方法。

  ```java
  Student m = new Student();
  m.school = "pku"; //合法,Student类有school成员变量
  
  Person e = new Student();
  e.school = “pku”; //非法,Person类没有school成员变量
  ```

  - 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而*编译错误*。  

### 虚拟方法调用 Virtual Method Invocation

编译时是左边的数据类型，运行时是右边的数据类型

子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。  

```java
Person e = new Student();
e.getInfo(); //调用Student类的getInfo()方法
// 编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。 ——动态绑定
```



### 总结

- 成员方法：
  - 编译时：要查看引用变量所声明的类中是否有所调用的方法。
  - 运行时： 调用实际new的对象所属的类中的重写方法。  
- 成员变量：  
  - 不具备多态性，只看引用变量所声明的类。